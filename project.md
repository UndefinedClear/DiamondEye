# Diamondeye — Техническая документация для разработчика

**Версия:** 9.0 (dev) | **Статус:** Internal Use Only
**Авторы:** larion, neo, teron | **Обновлено:** 2025

## Общая архитектура

Diamondeye — асинхронный HTTP-тестер, построенный по модульному принципу.

**Основные компоненты:**

1.  `main.py` — Точка входа, управление режимами
2.  `args.py` — Парсинг аргументов командной строки
3.  `attack.py` — Логика атаки, воркеры, статистика
4.  `scanner.py` — Режим сканирования (aiohttp)
5.  `utils.py` — Вспомогательные функции: заголовки, строки, размеры

**Связи:**

*   `main.py` → вызывает `args.parse_args()`
*   `main.py` → создаёт `attack.DiamondeyeAttack` или запускает `scanner.start_scan`
*   `attack.py` → использует `utils.generate_headers`, `utils.random_string`
*   `scanner.py` → независим, использует `aiohttp`

**Поток данных:**

`CLI → args → main → (attack | scanner) → HTTP → stats → report`

---

## Модуль: `main.py`

**Назначение:**

*   Точка входа
*   Определение режима: attack или scan
*   Валидация URL, конфликтов флагов
*   Запуск атаки или сканирования
*   Обработка сигналов (Ctrl+C)

**Ключевые функции:**

*   `main()` — Основной асинхронный цикл
*   `parse_args()` → из `args.py`
*   `generate_report()`, `save_json_report()`, `save_plot()` → Отчёты
*   `signal_handler()` → Перехват SIGINT/SIGTERM

**Особенности:**

*   Поддержка `uvloop` (авто-активация)
*   Авто-ограничение `workers` на localhost (CPU-based)
*   Авто-отключение `--slow` при `--flood`
*   Импорт `scanner` отложен (ленивая загрузка)

**Рекомендации:**

*   Не дублировать `if __name__ == "__main__":`
*   Все предупреждения выводить через `print` с цветом
*   Не хранить состояние в глобальных переменных

---

## Модуль: `args.py`

**Назначение:**

*   Парсинг CLI-аргументов
*   Валидация `--data-size`
*   Возврат объекта `args`

**Флаги:**

*   Все флаги описаны в `main.md` (пользовательская версия)
*   Особое внимание: `--data-size` → валидация через `validate_data_size`

**Валидация:**

*   `parse_data_size()` → из `utils.py`
*   Проверка: `k`, `m`, `kb`, `mb` → в байты
*   Ошибки: возвращает 0 при неверном формате

**Рекомендации:**

*   Добавить `--timeout <float>` — кастомный таймаут запроса
*   Добавить `--source-ip` — для тестов с разных IP
*   Поддержка `--rate-limit <rps>` — для этичных сценариев

---

## Модуль: `attack.py`

**Назначение:**

*   Управление атакой
*   Создание воркеров
*   Отправка запросов
*   Сбор статистики
*   Обработка ошибок

**Класс:** `DiamondeyeAttack`

**Поля:**

*   `url`, `workers`, `sockets`, `methods`
*   `useragents`, `no_ssl_check`, `proxy`, `use_http2`
*   `slow_rate`, `extreme`, `data_size`, `flood`, `path_fuzz`
*   `sent`, `failed`, `rps_history`, `latency_samples`
*   `_shutdown_event`, `_monitor_task`, `_rps_task`
*   `active_tasks`, `_slow_writers`

**Методы:**

1.  `__init__()` — Инициализация, защита от `args=None`
    *   Устанавливает атрибуты по умолчанию
    *   Инициализирует `ctf_paths`, `referers`
2.  `start()` — Запуск
    *   Создаёт пул клиентов (`httpx.AsyncClient`)
    *   Запускает worker-задачи
    *   Запускает `monitor` и `collect_rps_stats`
3.  `worker()` — Основной цикл
    *   Выбирает метод, URL, заголовки, тело
    *   Отправляет запрос
    *   С вероятностью `--slow` → запускает `slow_request`
    *   Пауза: 0.0001с (`--flood`) или случайная
4.  `send_request()` — Отправка через клиент
    *   Учитывает `--extreme` (временный клиент)
    *   `try/finally` для `acloses()`
5.  `slow_request()` — Медленный запрос (Slowloris)
    *   Открывает TCP-соединение через `asyncio.open_connection`
    *   Досылает заголовки с задержками
    *   Сохраняет writer в `_slow_writers`
    *   Закрывает при остановке
6.  `collect_rps_stats()` — Сбор RPS
    *   Каждую секунду: (current - last) → RPS
    *   Сохраняет в `rps_history`
7.  `monitor()` — Вывод статистики
    *   Каждые 0.5с → `print_stats()`
8.  `shutdown()` — Корректное завершение
    *   Устанавливает `_shutdown_event`
    *   Отменяет задачи
    *   Закрывает все writer’ы и клиенты
9.  `build_random_url()` — Генерация URL
    *   Использует `ctf_paths`, `paths`, `path_fuzz`
    *   Ограничивает длину до 512 символов
10. `get_random_method()` — Выбор метода
    *   Если `--method-fuzz` → 30% шанс на редкий метод

**Особенности:**

*   При `--extreme`: каждый запрос — новый `httpx.AsyncClient`
*   При `--flood`: пауза 0.0001с → максимум RPS
*   При `--data-size`: для `propfind` → XML, иначе JSON/строка

**Рекомендации:**

*   Добавить backpressure при высокой нагрузке
*   Поддержка HTTP/3 (QUIC) — в будущем
*   Логирование в файл (при `--debug`)
*   Возможность динамического изменения RPS (API)

---

## Модуль: `scanner.py`

**Назначение:**

*   Поиск уязвимых путей
*   Работает в режиме `--scan`
*   Независим от `httpx` (использует `aiohttp`)

**Функция:** `start_scan(target, wordlist, threads, output)`

**Логика:**

*   Загружает `wordlist` или использует `default_wordlist`
*   Создаёт `aiohttp.ClientSession` с SSL отключённым
*   Ограничивает потоки через `asyncio.Semaphore(threads)`
*   Для каждого пути:
    *   `urljoin(base_url, path)`
    *   GET-запрос с `allow_redirects=True`
    *   Если 301/302 и редирект в пределах домена → добавить в задачи
    *   Сохранить: URL, статус, редирект

**Особенности:**

*   Следует за редиректами (внутри домена)
*   Сохраняет результаты в `output`
*   Использует безопасные заголовки и таймауты

**Рекомендации:**

*   Добавить `--follow-all-redirects` (вне домена)
*   Поддержка POST-сканирования
*   Фильтр по размеру ответа (`--size-min`, `--size-max`)
*   Игнор по содержимому (`--exclude "not found"`)

---

## Модуль: `utils.py`

**Назначение:**

*   Вспомогательные функции

**Функции:**

1.  `random_string(length)` → `str`
    *   Генерирует строку из a-za-z0-9
    *   Используется для путей, заголовков
2.  `parse_data_size(size_str)` → `int`
    *   Поддержка: 1024, 1k, 64k, 1m, 1.5m
    *   Возвращает байты
    *   При ошибке → 0
3.  `generate_headers(...)` → `dict`
    *   Формирует стандартные заголовки
    *   Добавляет x-* при `--junk`
    *   До 20 заголовков при `--header-flood`
    *   Подменяет `host` при `--random-host`

**Рекомендации:**

*   Добавить поддержку кастомных заголовков (`--header "x-key: abc"`)
*   Поддержка случайных cookies
*   Генерация случайного тела (JSON, XML, form-data)

---

## Внутренняя безопасность

**Проблемы:**

1.  `args` может быть `None` → `AttributeError`
    *   Решено: `setattr` по умолчанию
2.  `temp_client` при `--extreme` → утечка при ошибке
    *   Решено: `try/finally` + `acloses()`
3.  Длинные URL → 414
    *   Решено: ограничение до 512 символов
4.  `--http2` + `--proxy` → ошибка
    *   Решено: предупреждение, отключение прокси

**Риски:**

*   Многие воркеры → исчерпание файловых дескрипторов
*   Медленные запросы → накопление writer’ов
*   Большой `data_size` → высокое потребление памяти

**Митигации:**

*   Ограничение `workers` на localhost (`psutil`)
*   Лимиты в `httpx.limits`
*   Закрытие writer’ов в `shutdown()`

---

## Расширение (Roadmap)

**Планы:**

1.  Поддержка HTTP/3 (QUIC)
2.  Веб-интерфейс (Flask + WebSocket)
3.  REST API для управления атакой
4.  Поддержка WebSocket (флуд соединений)
5.  Авто-тюнинг RPS (Adaptive Mode)
6.  Интеграция с Burp Suite (через Proxy API)
7.  Поддержка JWT-авторизации (`--auth-token`)
8.  Фаззинг JSON-тел (`--json-fuzz`)
9.  Экспорт в HAR, CSV
10. Поддержка плагинов (`plugins/`)

**Модули расширения:**

*   `plugins/`
    *   `plugin_cors.py`
    *   `plugin_jwt.py`
    *   `plugin_websocket.py`

---

## Заключение

Diamondeye — расширяемая, модульная система.

**Для разработчиков:**

*   Чёткое разделение ответственности
*   Легко добавлять новые режимы
*   Удобно тестировать отдельные части

**Советы:**

*   Перед коммитом: проверь RPS, память, ошибки
*   Используй `--debug` при разработке
*   Тестируй на localhost с малыми `-w` `-s`
*   Не коммить временные файлы (`found.txt`, `report.log`)

**Авторы:** larion, neo
**Лицензия:** MIT